The serial implementation had roughly 7-13 simulation frames per second (SFPS). For subproblem 1, 4 threads takes 14-18 SFPS. The speedup is not that significant, perhaps because of random access (poor spacial locality). For subproblem 2, 1 thread takes 1100-1500 SFPS and 4 threads takes 1700-2000 SFPS. This is because we significantly reduce the number of objects we check for each object (reducing O(N^2) to O(N)). For subproblem 3, 1 thread takes 1100-1500 SFPS and 4 threads takes 1900-2300 SFPS. This is increase is because of the improved space locality with sorting. For subproblem 4, adding locks reduces to 800-1200 SFPS. This is because of the overhead in initializing, acquiring, releasing, and waiting for locks. I chose the Morton ordering technique because it made the most sense to interleave the coordinates to compare our positions one dimensionally, and sort based on that. This provided me with the most intuitive nearest neighbor search to improve space locality.