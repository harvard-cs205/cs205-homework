# Problem 5 writeup.

Note: all results are averages of simulation frames per second over 100 steps

Subproblem 1: Multithreading
1 Thread:
Average: 11.0632488682 simulation frames per second
2 Threads:
Average: 15.1637291089 simulation frames per second
3 Threads:
Average: 15.5707373472 simulation frames per second
4 Threads:
Average: 15.6020275958 simulation frames per second

Most of the gain in performance is achieved from increasing the number of threads from 1 -> 2, which corresponds to a speedup of only about 1.37. In comparison, the speedup from 1 -> 4 threads is 1.41. 


Subproblem 2: Spatial Decomposition
1 Thread:
Average: 462.64598214 simulation frames per second
Speedup (vs. no SD): 41.8
2 Threads:
Average: 658.312696733 simulation frames per second
Speedup (vs. no SD): 43.4 
Speedup (vs. 1 thread): 1.42 
3 Threads:
Average: 584.392212232 simulation frames per second
Speedup	 (vs. no SD): 37.5
Speedup	 (vs. 1 thread): 1.26
4 Threads:
Average: 566.045982141 simulation frames per second
Speedup	 (vs. no SD): 36.3
Speedup	 (vs. 1 thread): 1.22

Clearly, transforming this problem by using another data structure to reduce the search space significantly increases the performance by over an order of magnitude (speedup of around 40 for all threads). There is speedup from additional threads, but it seems that much of the benefit of multithreading is lost after two threads; in fact, compared to just two threads, three and four threads do not perform as well. It is possible that the overhead from multithreading is even higher due to spatial decomposition than earlier, which causes increased numbers of threads to yield decreased performances. 


Subproblem 3: Spatially Coherent Sorting
1 Thread:
Average: 505.98891243 simulation frames per second
Speedup (vs. no sort): 1.09
2 Threads:
Average: 731.648665672 simulation frames per second
Speedup (vs. no sort): 1.11
3 Threads:
Average: 665.977816924 simulation frames per second
Speedup (vs. no sort): 1.14
4 Threads:
Average: 683.25863594 simulation frames per second
Speedup (vs. no sort): 1.21

Hilbert ordering is better at preserving locality than Morton ordering; however, Morton ordering is generally computationally less expensive. Thus, I chose Morton ordering as my sorting algorithm.

There is an increase in performance due to adding sorting, as demonstrated in the speedup values when compared to the absence of sorting. However, adding threads leads to increased performance, but the gain does not seem to be too significant beyond two threads (in fact, the performance dips with additional threads).


Subproblem 4: Locking
1 Thread:
Average: 321.290744538 simulation frames per second
Speedup (vs. no lock): 0.63
2 Threads:
Average: 519.855134945 simulation frames per second
Speedup	 (vs. no lock):	0.71	  
3 Threads:
Average: 468.877632942 simulation frames per second
Speedup	 (vs. no lock):	0.70	  
4 Threads:
Average: 556.210696376 simulation frames per second
Speedup	 (vs. no lock): 0.81

Locking causes a slowdown in performance regardless of the thread count. However, this slowdown still yields a performance much higher than before any of the other manipulations to this code (multithreading, spatial decomposition, sorting). Locking protects our data from multiple collisions being processed improperly. 
