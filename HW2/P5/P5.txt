The results reproduced below are small snapshots of some of the output generated by the animation's command line logging.

Problem 1. Multithreading
-------------------------
Results
~~~~~~~
1 Thread
6.85302359171 simulation frames per second
6.97456977473 simulation frames per second
6.86002891667 simulation frames per second
6.9333756513 simulation frames per second
6.95081749875 simulation frames per second
6.43940124357 simulation frames per second
6.93904210439 simulation frames per second
6.92132799337 simulation frames per second
6.92751248646 simulation frames per second
6.90279514963 simulation frames per second
6.88292652508 simulation frames per second
6.25370550671 simulation frames per second

4 Threads
12.4192878822 simulation frames per second
14.8425228337 simulation frames per second
12.7914510261 simulation frames per second
13.8550249729 simulation frames per second
14.8738931384 simulation frames per second
13.4640391116 simulation frames per second
13.4700061982 simulation frames per second
13.1628955016 simulation frames per second
15.1434771149 simulation frames per second
13.4905421879 simulation frames per second

Analysis
~~~~~~~~
Running this on a single thread is apallingly slow. Introducing basic multithreading naturally improves performance, though even on 4 threads, the improvement is not 4x as we may have expected. The increase is from approximately 6-7 frames to 12-15 frames which is approximately a 2x increase. I suspect this for the overhead of setting up and communicating between threads that is an expected cost of the parallelization, so this does not surprise me

Problem 2. Grid
----------------
Results
~~~~~~~
1 Thread
683.9007777 simulation frames per second
651.76787026 simulation frames per second
674.598900715 simulation frames per second
639.163027818 simulation frames per second
580.542575573 simulation frames per second
724.980813773 simulation frames per second
707.064059339 simulation frames per second
726.719292531 simulation frames per second
655.546234726 simulation frames per second
695.981581222 simulation frames per second
680.811816764 simulation frames per second
566.890572426 simulation frames per second

4 Threads
1309.86412287 simulation frames per second
1315.05369969 simulation frames per second
1224.0477187 simulation frames per second
1073.40185837 simulation frames per second
1047.48362422 simulation frames per second
885.646555365 simulation frames per second
1079.32939234 simulation frames per second
1051.8630721 simulation frames per second
563.354729998 simulation frames per second
1150.65211978 simulation frames per second
1076.89689258 simulation frames per second
1034.55774259 simulation frames per second

Analysis
~~~~~~~~
Introducing the grid yields some incredible results. On one thread, the speedup is approximately 100x to a range of 550-730 and on 4 threads the speedup is a bit less, around 80x from the 4-threaded gridless version. This speedup is expected since the algorithm is linear instead of polynomial. At the same time, on the small test simulation, it seems to be that the balls overlap more frequently and to a greater degree than they did without the grid. Though I cannot confirm this in any systematic manner, it may be the case that we gain a performance boost by trading off collision detection accuracy. Ultimately though, the combination of algorithm optimization and multithreading boosts performance very noticeably (though the algorithm improvement clearly holds more weight).

Problem 3. Sorting
----------------
Results
~~~~~~~
1 Thread
701.579275305 simulation frames per second
903.706084321 simulation frames per second
872.601386963 simulation frames per second
872.262644188 simulation frames per second
905.827770463 simulation frames per second
871.061022464 simulation frames per second
869.702240844 simulation frames per second
900.501585982 simulation frames per second
873.503967345 simulation frames per second
779.92822354 simulation frames per second

4 Threads
1644.55540268 simulation frames per second
2649.96809757 simulation frames per second
2404.22495382 simulation frames per second
1709.7589452 simulation frames per second
2251.73668633 simulation frames per second
2512.88486941 simulation frames per second
2345.35929614 simulation frames per second
1996.52136351 simulation frames per second
1998.60866102 simulation frames per second

Analysis
~~~~~~~~
For this problem, I used Morton coding, as I was familiar with it from CS207 and know that it is generally a good way to flatten coordinates in 2 dimensions into a single curve. I used bitshift operations found on a Stanford course webpage to compute the interleavings of the coordinates and used these interleavings as the keys to sort the coordinates appropriately.
The efficacy of the sorting surprised me. I understand that since my collision detection checks the 5x5 bounding box of a single ball's grid space, we only ever check balls that are near our target ball. This means that if they are sorted closer together in memory, we can expect to experience marginal improvements in the collision detection.
However, the performance boosts (ignoring the thread counts) for the sorting here were on the order of 20%-30% improvements, which is significant enough to be considered more than just "marginal"
For the 4 thread case, the improvement was nearly 2x! This shows that multithreading in conjuction with Morton coding improves performance exceptionally well. I expect that this is explained by the fact that since each thread benefits from the 30% improvement seen in the 1 thread case, together the 4 threads amount to roughly a 100% improvement, since these would necessarily "stack" when parallelized.  

Problem 4. Locking
----------------
Results
~~~~~~~
No Locking (4 threads)
1644.55540268 simulation frames per second
2649.96809757 simulation frames per second
2404.22495382 simulation frames per second
1709.7589452 simulation frames per second
2251.73668633 simulation frames per second
2512.88486941 simulation frames per second
2345.35929614 simulation frames per second
1996.52136351 simulation frames per second
1998.60866102 simulation frames per second

Locking (4 threads)
1093.49037845 simulation frames per second
1226.24726536 simulation frames per second
1769.47012556 simulation frames per second
1733.64047234 simulation frames per second
1988.58139206 simulation frames per second
1866.62394304 simulation frames per second
1853.96818879 simulation frames per second
1907.30104234 simulation frames per second
1425.52573315 simulation frames per second
1956.43676764 simulation frames per second
1888.21906218 simulation frames per second

Analysis
~~~~~~~~
It comes as no surprise that locking slows down the performance. Although this can be explained by the fact that there exists some overhead to acquiring and releasing locks, I think the true cause of this decrease is the lock contention for each ball. What thsi means is that the accuracy issues in Part 2 are being resolved and the balls are colliding with each other more correctly. Though I cannot guarantee that this is the case, a holistic view of the animatiuon as well as these results seem to confirm my hypothesis. Thus, given our combined use of Gridding, Morton sorting, and Multithreading, we can intriduce locks to restore most of the accuracy that was lost in the gridding and multithreading phases and can still boast a performance better than gridding alone yielded us.
