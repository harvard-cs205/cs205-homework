With fine grained locking, the time for the completion of the transfer increased from the time it took for serial to complete. This was as expected since there is an overhead to aquiring and releasing locks that has to happen every single time an action is to be performed, so even though there are now 4 threads working on the counts, the overhead of parallelizing seems to overshadow the benefit of more workers. However, it still seems like a large increase of time -- from .4s serial uncorrelalted to 3.3s seconds fine-grained locking uncorrelated and from .5 serial to 2.5s fine grained locking correlated. The overhead of locking is just too much for a problem that requires so quick computation -- adding and subtracting a digit for each time in the loop is incredibly quick, so no matter how quick locking and releasing takes, the computation takes much less. So we can conclude multithreading is useful if the work the threads are doing is more computationally heavy, which would outweigh the overheading locking.

With medium grained locking (N = 10), the time increased even more, again as expected because there is now an increased chance of a thread waiting for another now that the lock size increased. (6.1s for uncorrelated and 5.3s for correlated). It was slightly better for correlated since now, the thread would only need to get a single lock more often when the transfers are to the same block contained within a lock.

After playing around with the N, I found that the speed is approximately the same across the board, except when N is large, which slows things down. Smaller values of N increased the time slightly. Therefore, the N value should be around 10 -- I did not find anything that improved the value.