The graphs P2_random.png and P2_correlated.png show the results for random and correlated data exchanges, respectively.

Overall, the serial code is significantly faster than both the fine-grained and medium-grained locking, for both random and correlated data exchanges. This is due to the fact that the operations being parallelized are bound by bandwidth, not compute, so any degree of locking will inevitably slow them down.

Using fine-grained locks is approximately 25 times slower than the serial code for the random data exchanges, and approximately 18 times slower for the correlated data exchanges. The faster run-time of the correlated code is most likely due to the increased probability of the src and dest arrays pointing to the same counts index. In this case, only one lock must be acquired and released instead of two, reducing both the number of operations and the likelihood of getting stuck while waiting for another thread to release the required lock(s).

The same characteristic shows up when comparing the medium-grained locks for different values of N in the correlated case. The graph P2_correlated.png shows that the runtime decreases between N=1 and (approximately) N=20, after which it plateaus. Again, this relates to the likelihood of the src and dest arrays being in the same lock "block", which is maximized at N=20 as the values in the dest array are at most +10 or -10 away from the values in the src array.

By comparison, no such trend is observed for random data exchanges in P2_random.png. Instead, the run-time increases steadily as a function of N, as more and more of the elements become unavailable with each lock that is acquired, and it becomes increasingly likely that threads will need to wait for one or both of the locks that they require. On this basis, the optimal value of N for medium-grained locking is N=1. It is interesting to note that fine-grained locking outperforms medium-grained locking for all values of N; the medium-grained locking appears to be suffering from a slight computational overhead associated with the calculation of identifying the correct lock "block".