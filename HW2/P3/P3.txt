--- Multithreading without Instruction-level Parallelism ---

For now we just compare the code efficiency when only the rows parallelized with a prange.

1 thread:

1074.656613 Million Complex FMAs in 4.0765440464 seconds, 263.619526925 million Complex FMAs / second

2 threads:

1074.656613 Million Complex FMAs in 2.06194496155 seconds, 521.185886646 million Complex FMAs / second

4 threads:

1074.656613 Million Complex FMAs in 1.10520887375 seconds, 972.356120662 million Complex FMAs / second

Because this problem is embarassingly parallel, multitheading reduces the run time: 2 threads divides the run time roughly by 2, 4 threads divide the run time roughly by 4.

A strange thing happens with prange when using 1 thread. The code is slower with 1 thread and prange than when using  a simple range without parallelizing.



-- Multithreading with Instruction-level Parallelism  --

Now we compare with both parallelization of the rows (with 1 to 4 threads and using prange) and the columns (with AVX)

1 thread:

1074.949755 Million Complex FMAs in 1.16745305061 seconds, 920.764868819 million Complex FMAs / second

2 threads: 

1074.949755 Million Complex FMAs in 0.583459854126 seconds, 1842.3714115 million Complex FMAs / second

4 threads:

1074.949755 Million Complex FMAs in 0.296026945114 seconds, 3631.25645399 million Complex FMAs / second

It looks like AVX gives us a speeding factor of roughly four when parallelizing the columns. It is not 8 because we actually do more computations (1074.949755 Million Complex FMAs instead of 1074.656613 Million Complex FMAs) using only prange. This is because in the previous version we used break once one value of z has a magnitude higher than 4 while here, with AVX, we use break when 8 adjacent values have a magnitude higher than 4.



We show the plot generated by 4 threads + AVX in plot_P3.png 