I chose to coordinate between threads using `threading.Event` objects. Events are simple objects that are either set or unset (unset by default). I used one event for each (thread, iteration) pair. Before doing a pass of filtering, each thread checks whether its neighbors have completed their previous pass first by checking their event. At the end of each pass, the thread sets its event to "set," signaling completion to the other threads. This allows each thread n to run iteration i once threads n, n - 1, and n + 1 have completed iteration i - 1. 

As one can see in the chart (P4.png), filtering with 2 threads is about twice as fast as filtering with one, while there is not much of a speedup when moving from 2 to 4 threads. Each new thread introduces additional overhead (new Thread and Event objects, more logic to coordinate between threads, etc.). In particular, when there are just 2 threads, each thread only has to check one other thread to see if it can continue to the next pass. When there are 4, however, the "middle" two threads have to check 2 neighbors, so coordination is considerably more complicated. This may contribute to the lack of much speedup as well.