### Times for various thread counts ###
1 thread - 3.38738298416 seconds for 10 filter passes.
2 threads - 1.58780503273 seconds for 10 filter passes.
4 threads - 0.971033811569 seconds for 10 filter passes.

### After big benefits from increasing the number of threads from 1 to 9, the benefit of having more threads past around 10 becomes very tiny, or even detrimental ###
8 threads - 0.868140935898 seconds for 10 filter passes.
9 threads - 0.739781141281 seconds for 10 filter passes.
10 threads - 0.751037836075 seconds for 10 filter passes.
15 threads - 0.726655960083 seconds for 10 filter passes.

Doubling the number of threads from 1 to 2, more than halves the runtime.  Doubling the thread count from 2 to 4 almost halves the run time, but not quite.  As we increase the number of threads beyond 4, we see that the speed up becomes smaller and smaller.  Clearly it is hitting some other limit.

I chose to use threading.Event() objects to control cooperation amongst the threads.  An indpendent event exists for each iteration-thread id combination.  Threads then wait on the events of their neighboring threads (wrapping around for first and last threads) for the same iteration to ensure that all filtering computation is ready for the thread for the next iteration.

All threads may begin an iteration of filtering asynchronously as long as their neighboring threads for the previous iteration are complete.