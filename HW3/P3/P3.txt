P3.txt

The platforms detected are:
---------------------------
Apple Apple version: OpenCL 1.2 (May 10 2015 19:38:45)
The devices detected on platform Apple are:
---------------------------
Intel(R) Core(TM) i5-4260U CPU @ 1.40GHz [Type: CPU ]
Maximum clock Frequency: 1400 MHz
Maximum allocable memory size: 2147 MB
Maximum work group size 1024
Maximum work item dimensions 3
Maximum work item size [1024, 1, 1]
---------------------------
HD Graphics 5000 [Type: GPU ]
Maximum clock Frequency: 1000 MHz
Maximum allocable memory size: 402 MB
Maximum work group size 512
Maximum work item dimensions 3
Maximum work item size [512, 512, 512]
---------------------------

configuration ('coalesced', 128, 128): 0.00316304 seconds

BBased on my configuration (Mac Air ~2014) the coalesced read and sum with 128 work_groups and 128 workers came out as the winner. Based on the coalesced plot that I created for the output data, it is easy to see that as the number of work groups increases, the execution time of the sums decreases. This indicates that having a larger work group size helps increase performance when reading from memory in the coalesced manner.

The block sum plot tells a different story. It seems that the optimal group size is 8 and that as the number of workers increases so does the performance. However, as we begin to increase the amount of work groups as well as workers, there is actually a decrease in performance. This maybe because the stride of k based on the global_size going out of memory bounds, which results in less work done per iteration and therefore decreased performance.