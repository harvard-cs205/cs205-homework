Part 1
-----------------------------------------------------------------------------
Maze 1:
    Iterations: 912
    Avg kernel execution time: 0.286 ms

Maze 2:
    Iterations: 530
    Avg kernel execution time: 0.285 ms


Part 2
-----------------------------------------------------------------------------
Maze 1:
    Iterations: 912
    Avg kernel execution time: 0.289 ms

Maze 2:
    Iterations: 531
    Avg kernel execution time: 0.289 ms


Part 3
-----------------------------------------------------------------------------
Maze 1:
    Iterations: 844
    Avg kernel execution time: 0.291 ms

Maze 2:
    Iterations: 530
    Avg kernel execution time: 0.287 ms



Part 5
-----------------------------------------------------------------------------
Using min() could result in an incorrect result due to the classic “Thread 1 reads a value, Thread 2 reads the same value, and they both write back what are now incorrect values” problem. This would happen when labels[old_label] is updated to new_label, because multiple threads work with the same value for old_label.

If this happened, the algorithm would probably take more iterations to finish because at each iteration, some updates would be “lost” and would have to be re-updated at the next iteration. In effect, this would partially render the optimization useless. However, it would probably finish faster per iteration since min() is faster than atomic_min().

A value in labels could increase. Suppose we had the following situation:

Thread 1: labels[old_label]=10, new_label=5
Thread 2: labels[old_label]=10, new_label=1

Thread 1 reads labels[old_label]. Then Thread 2 reads labels[old_label] and writes in 1. Finally, Thread 1 gets around to writing in 5. In this case, labels[old_label] has gone 10->1->5.

However, this could not occur between iterations, since it’s always true that min(labels[old_label], new_label) <= labels[old_label]. At worst, labels[old_label] will not decrease as much as it should between iterations.