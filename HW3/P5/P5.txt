•PART 1•
Maze 1: Finished after 885 iterations, 285.21048 ms total, 0.322271728814 ms per iteration
Maze 2:Finished after 519 iterations, 166.55048 ms total, 0.320906512524 ms per iteration

•PART 2•

Maze 1: Finished after 528 iterations, 170.21328 ms total, 0.322373636364 ms per iteration
Maze 2: Finished after 273 iterations, 87.60856 ms total, 0.32091047619 ms per iteration

•PART 3•

Maze 1: Finished after 11 iterations, 3.51776 ms total, 0.319796363636 ms per iteration
Maze 2: Finished after 10 iterations, 3.12064 ms total, 0.312064 ms per iteration

•PART 4•

Maze 1: Finished after 10 iterations, 8.09776 ms total, 0.809776 ms per iteration
Maze 2: Finished after 10 iterations, 7.96824 ms total, 0.796824 ms per iteration

The first thing we note is that implementing the efficient grandparents methods doesn’t improve the number of iterations necessary to complete the maze and moreover slows down each iteration (more than twice as slow). This, of course, comes from the serialisation of the issue at hand. 

•PART 5•

Switching from atomic_min() to min()