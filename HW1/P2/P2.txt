Problem 2:

My initial RDD construction included the use of .cartesian() between two 1x2000 RDDs each of partition 10. The combination results in 100 partitions and an RDD of all the 2000x2000 pixels. The partitions are initially set up by sequential slices of our 2000x2000 pixel area. This leads to problems as we will see.

When first plotting the image, it can be seen that there are a few concentrated areas of high iteration count (bright spots) and many areas of low/no iteration counts (black areas). Given our initial partitioning strategy, this means that most workers would have been assigned the ‘black’ areas and had fairly little computation to carry out, while a few (unlucky) workers were assigned the bright areas and were stuck doing most of the computation. My first histogram reflects this where most workers had low iteration counts and a few workers had high iteration counts.

To fix this, i used the .repartition() method to randomly repartition my RDD into 100 random partitions. This effectively distributes a random 1/100 of the pixels to each worker to more evenly distribute the computation across our 100 workers. My 2nd histogram reflects this change where we now have a more balanced load of work across workers. Repartitioning an RDD does involve a cost of time in it of itself, but one would repartition to hopefully save more time moving forward due to this transformation. 


