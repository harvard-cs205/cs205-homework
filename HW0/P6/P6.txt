1. Running P6A.py a number of times shows the threads may start in any order and that each of the threads running in parallel is not guaranteed to finish their execution in the order that they started. Moreover, threads that finish before others can begin running a new job before others in the pool have finished. This affects the way we must reason about our programs when programming in parallel. We no longer have guarantees of order, which we usually have with serial loops. This could be a problem if, for instance, each job is modifying the same object in memory. Order matters here if your computation if non-commutative. Consider a sequence of (square) matrix multiplications, where each multiplication stores the result in place. Then here the parallel sequence of multiplications is not guaranteed to give the correct answer. This bug maybe be non-obvious to the programmer, so knowing about these pitfalls is imperative.

2. The serial version is faster than the parallel version for small sleep times---approximately sleep times which are less than 10^-4.5 seconds. At around 10^-4.5 seconds, the serial and parallel version are about the same. Above 10^-4.5 seconds, the parallel version is faster. The fastest speedup that the parallel version can attain is 4x, which is achieved at a little above 10^-3 seconds of sleep time and maintained for longer sleep times. This corresponds to all 4 processes in the pool doing their maximum amount of work, where no time is wasted in communication overhead. The parallel version can take longer than the serial version for small sleep times because the overhead of launching the jobs on the threads and communicating with them outweighs the sleep time.
